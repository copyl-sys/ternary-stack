@* libt81.cweb | Base-81 Arithmetic Core
This module implements Base-81 (T81) digit and number arithmetic logic, using safe C abstractions.
Each digit encodes 4 ternary digits. This module enables symbolic and packed ternary computation
and defines a standard interface via `libt81.h`.

Included Features:
- `T81Digit`: Integer wrapper from 0–80
- `T81Number`: Vector of digits (little-endian) + sign
- Arithmetic: `add`, `sub`, `mul`, `neg`
- Display formatting and normalization
@#

@<Include Dependencies@>=
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
@#

@<T81 Digit Type@>=
typedef struct {
    uint8_t val; // Must be 0–80
} T81Digit;
@#

@<T81 Number Type@>=
typedef struct {
    T81Digit* digits;  // Least-significant digit first
    size_t    length;
    bool      negative;
} T81Number;
@#

@<T81 Utility Functions@>=
T81Digit new_digit(uint8_t val) {
    if (val >= 81) {
        fprintf(stderr, "[T81] Invalid digit: %u\n", val);
        exit(1);
    }
    return (T81Digit){ .val = val };
}

T81Number t81_zero() {
    T81Number z;
    z.digits = malloc(sizeof(T81Digit));
    z.digits[0] = new_digit(0);
    z.length = 1;
    z.negative = false;
    return z;
}

T81Number t81_one() {
    T81Number o;
    o.digits = malloc(sizeof(T81Digit));
    o.digits[0] = new_digit(1);
    o.length = 1;
    o.negative = false;
    return o;
}

void t81_normalize(T81Number* num) {
    while (num->length > 1 && num->digits[num->length - 1].val == 0) {
        num->length--;
    }
    if (num->length == 1 && num->digits[0].val == 0) {
        num->negative = false;
    }
}
@#

@<T81 Arithmetic@>=
T81Number t81_add(const T81Number* a, const T81Number* b);
T81Number t81_sub(const T81Number* a, const T81Number* b);
T81Number t81_mul(const T81Number* a, const T81Number* b);
T81Number t81_negate(const T81Number* n);

T81Number t81_add(const T81Number* a, const T81Number* b) {
    size_t max_len = (a->length > b->length) ? a->length : b->length;
    T81Digit* result = calloc(max_len + 1, sizeof(T81Digit));
    int carry = 0;

    for (size_t i = 0; i < max_len; ++i) {
        int av = (i < a->length) ? a->digits[i].val : 0;
        int bv = (i < b->length) ? b->digits[i].val : 0;
        int sum = av + bv + carry;
        result[i].val = sum % 81;
        carry = sum / 81;
    }

    if (carry > 0) {
        result[max_len].val = carry;
        max_len++;
    }

    T81Number out = { result, max_len, false };
    t81_normalize(&out);
    return out;
}
@#

@<T81 Negation and Subtraction@>=
T81Number t81_negate(const T81Number* n) {
    T81Number r;
    r.length = n->length;
    r.digits = malloc(sizeof(T81Digit) * r.length);
    memcpy(r.digits, n->digits, r.length * sizeof(T81Digit));
    r.negative = !n->negative;
    return r;
}

T81Number t81_sub(const T81Number* a, const T81Number* b) {
    T81Number b_neg = t81_negate(b);
    T81Number result = t81_add(a, &b_neg);
    free(b_neg.digits);
    return result;
}
@#

@<T81 Multiplication@>=
T81Number t81_mul(const T81Number* a, const T81Number* b) {
    size_t res_len = a->length + b->length;
    T81Digit* result = calloc(res_len, sizeof(T81Digit));

    for (size_t i = 0; i < a->length; ++i) {
        int carry = 0;
        for (size_t j = 0; j < b->length; ++j) {
            int av = a->digits[i].val;
            int bv = b->digits[j].val;
            int sum = av * bv + result[i + j].val + carry;
            result[i + j].val = sum % 81;
            carry = sum / 81;
        }
        result[i + b->length].val += carry;
    }

    T81Number out = { result, res_len, a->negative ^ b->negative };
    t81_normalize(&out);
    return out;
}
@#

@<T81 Debug Print@>=
void t81_print(const T81Number* n) {
    if (n->negative) printf("-");
    for (ssize_t i = n->length - 1; i >= 0; --i) {
        printf("%u ", n->digits[i].val);
    }
    printf("\n");
}
@#

@h libt81.h
#ifndef LIBT81_H
#define LIBT81_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

typedef struct { uint8_t val; } T81Digit;

typedef struct {
    T81Digit* digits;
    size_t    length;
    bool      negative;
} T81Number;

T81Digit new_digit(uint8_t val);
T81Number t81_zero(void);
T81Number t81_one(void);
void      t81_normalize(T81Number* n);
T81Number t81_add(const T81Number* a, const T81Number* b);
T81Number t81_sub(const T81Number* a, const T81Number* b);
T81Number t81_mul(const T81Number* a, const T81Number* b);
T81Number t81_negate(const T81Number* a);
void      t81_print(const T81Number* n);

#endif
@#
