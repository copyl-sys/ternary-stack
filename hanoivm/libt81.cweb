@* libt81.cweb | Base-81 Arithmetic and Symbolic Core
This module defines the T81 arithmetic and symbolic types used in HanoiVM.
All data types are production-ready, FFI-safe, and support symbolic ternary processing.

Included Types:
- Core: `T81BigInt`, `T81Float`, `T81Fraction`
- Structures: `T81Vector`, `T81Matrix`
- Fully embedded `libt81.h` via `@h` block
@#

@<Include Dependencies@>=
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
@#

@<T81BigInt Internal Definition@>=
typedef struct T81BigIntImpl {
    int64_t value;
} T81BigIntImpl;
@#

@<T81Float Internal Definition@>=
typedef struct T81FloatImpl {
    double value;
} T81FloatImpl;
@#

@<T81Fraction Internal Definition@>=
typedef struct T81FractionImpl {
    T81BigInt numerator;
    T81BigInt denominator;
} T81FractionImpl;
@#

@<T81Vector Internal Definition@>=
typedef struct T81VectorImpl {
    T81Float* data;
    size_t dimension;
} T81VectorImpl;
@#

@<T81Matrix Internal Definition@>=
typedef struct T81MatrixImpl {
    T81Float* data;
    size_t rows;
    size_t cols;
} T81MatrixImpl;
@#

@<T81 Integer Utility Functions@>=
static int64_t t81_gcd(int64_t a, int64_t b) {
    if (a < 0) a = -a;
    if (b < 0) b = -b;
    while (b != 0) {
        int64_t t = b;
        b = a % b;
        a = t;
    }
    return a;
}
@#

@<T81BigInt Functions@>=
T81BigInt t81_bigint_new_from_int64(int64_t value) {
    T81BigIntImpl* bigint = malloc(sizeof(T81BigIntImpl));
    if (!bigint) exit(1);
    bigint->value = value;
    return bigint;
}

T81BigInt t81_bigint_add(T81BigInt a, T81BigInt b) {
    return t81_bigint_new_from_int64(a->value + b->value);
}

T81BigInt t81_bigint_sub(T81BigInt a, T81BigInt b) {
    return t81_bigint_new_from_int64(a->value - b->value);
}

T81BigInt t81_bigint_mul(T81BigInt a, T81BigInt b) {
    return t81_bigint_new_from_int64(a->value * b->value);
}

T81BigInt t81_bigint_neg(T81BigInt x) {
    return t81_bigint_new_from_int64(-x->value);
}

void t81_bigint_free(T81BigInt x) {
    free(x);
}
@#

@<T81Float Functions@>=
T81Float t81_float_new(double value) {
    T81FloatImpl* f = malloc(sizeof(T81FloatImpl));
    if (!f) exit(1);
    f->value = value;
    return f;
}

T81Float t81_float_add(T81Float a, T81Float b) {
    return t81_float_new(a->value + b->value);
}

T81Float t81_float_mul(T81Float a, T81Float b) {
    return t81_float_new(a->value * b->value);
}

T81Float t81_float_inv(T81Float x) {
    if (x->value == 0.0) exit(1);
    return t81_float_new(1.0 / x->value);
}

T81Float t81_float_sub(T81Float a, T81Float b) {
    return t81_float_new(a->value - b->value);
}

void t81_float_free(T81Float x) {
    free(x);
}
@#

@<T81Fraction Functions@>=
T81Fraction t81_fraction_new(T81BigInt num, T81BigInt denom) {
    if (denom->value == 0) exit(1);
    T81FractionImpl* f = malloc(sizeof(T81FractionImpl));
    if (!f) exit(1);
    f->numerator = num;
    f->denominator = denom;
    return f;
}

T81Fraction t81_fraction_reduce(T81Fraction f) {
    int64_t n = f->numerator->value;
    int64_t d = f->denominator->value;
    int64_t g = t81_gcd(n, d);
    if (g == 0) return f;
    T81BigInt num = t81_bigint_new_from_int64(n / g);
    T81BigInt den = t81_bigint_new_from_int64(d / g);
    return t81_fraction_new(num, den);
}

void t81_fraction_free(T81Fraction f) {
    t81_bigint_free(f->numerator);
    t81_bigint_free(f->denominator);
    free(f);
}
@#

@<T81Vector Functions@>=
T81Vector t81_vector_new(size_t dimension) {
    T81Vector v = malloc(sizeof(T81VectorImpl));
    if (!v) exit(1);
    v->dimension = dimension;
    v->data = calloc(dimension, sizeof(T81Float));
    for (size_t i = 0; i < dimension; ++i)
        v->data[i] = t81_float_new(0.0);
    return v;
}

T81Float t81_vector_dot(T81Vector a, T81Vector b) {
    if (a->dimension != b->dimension) exit(1);
    T81Float sum = t81_float_new(0.0);
    for (size_t i = 0; i < a->dimension; ++i) {
        T81Float p = t81_float_mul(a->data[i], b->data[i]);
        T81Float new_sum = t81_float_add(sum, p);
        t81_float_free(p);
        t81_float_free(sum);
        sum = new_sum;
    }
    return sum;
}

T81Vector t81_vector_cross(T81Vector a, T81Vector b) {
    if (a->dimension != 3 || b->dimension != 3) exit(1);
    T81Vector r = t81_vector_new(3);
    r->data[0] = t81_float_sub(
        t81_float_mul(a->data[1], b->data[2]),
        t81_float_mul(a->data[2], b->data[1]));
    r->data[1] = t81_float_sub(
        t81_float_mul(a->data[2], b->data[0]),
        t81_float_mul(a->data[0], b->data[2]));
    r->data[2] = t81_float_sub(
        t81_float_mul(a->data[0], b->data[1]),
        t81_float_mul(a->data[1], b->data[0]));
    return r;
}

void t81_vector_free(T81Vector v) {
    for (size_t i = 0; i < v->dimension; ++i)
        t81_float_free(v->data[i]);
    free(v->data);
    free(v);
}
@#

@<T81Matrix Functions@>=
T81Matrix t81_matrix_new(size_t rows, size_t cols) {
    T81Matrix m = malloc(sizeof(T81MatrixImpl));
    if (!m) exit(1);
    m->rows = rows;
    m->cols = cols;
    m->data = calloc(rows * cols, sizeof(T81Float));
    for (size_t i = 0; i < rows * cols; ++i)
        m->data[i] = t81_float_new(0.0);
    return m;
}

T81Float t81_matrix_get(T81Matrix m, size_t row, size_t col) {
    return m->data[row * m->cols + col];
}

void t81_matrix_set(T81Matrix m, size_t row, size_t col, T81Float val) {
    m->data[row * m->cols + col] = val;
}

T81Matrix t81_matrix_mul(T81Matrix a, T81Matrix b) {
    if (a->cols != b->rows) exit(1);
    T81Matrix r = t81_matrix_new(a->rows, b->cols);
    for (size_t i = 0; i < a->rows; ++i) {
        for (size_t j = 0; j < b->cols; ++j) {
            T81Float sum = t81_float_new(0.0);
            for (size_t k = 0; k < a->cols; ++k) {
                T81Float p = t81_float_mul(
                    t81_matrix_get(a, i, k),
                    t81_matrix_get(b, k, j));
                T81Float new_sum = t81_float_add(sum, p);
                t81_float_free(p);
                t81_float_free(sum);
                sum = new_sum;
            }
            t81_matrix_set(r, i, j, sum);
        }
    }
    return r;
}

void t81_matrix_free(T81Matrix m) {
    for (size_t i = 0; i < m->rows * m->cols; ++i)
        t81_float_free(m->data[i]);
    free(m->data);
    free(m);
}
@#

@h libt81.h
#ifndef LIBT81_H
#define LIBT81_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

typedef struct T81BigIntImpl*     T81BigInt;
typedef struct T81FloatImpl*      T81Float;
typedef struct T81FractionImpl*   T81Fraction;
typedef struct T81VectorImpl*     T81Vector;
typedef struct T81MatrixImpl*     T81Matrix;

// T81BigInt
T81BigInt t81_bigint_new_from_int64(int64_t value);
T81BigInt t81_bigint_add(T81BigInt a, T81BigInt b);
T81BigInt t81_bigint_sub(T81BigInt a, T81BigInt b);
T81BigInt t81_bigint_mul(T81BigInt a, T81BigInt b);
T81BigInt t81_bigint_neg(T81BigInt x);
void      t81_bigint_free(T81BigInt x);

// T81Float
T81Float  t81_float_new(double value);
T81Float  t81_float_add(T81Float a, T81Float b);
T81Float  t81_float_mul(T81Float a, T81Float b);
T81Float  t81_float_inv(T81Float x);
T81Float  t81_float_sub(T81Float a, T81Float b);
void      t81_float_free(T81Float x);

// T81Fraction
T81Fraction t81_fraction_new(T81BigInt num, T81BigInt denom);
T81Fraction t81_fraction_reduce(T81Fraction f);
void        t81_fraction_free(T81Fraction f);

// T81Vector
T81Vector t81_vector_new(size_t dimension);
T81Vector t81_vector_cross(T81Vector a, T81Vector b);
T81Float  t81_vector_dot(T81Vector a, T81Vector b);
void      t81_vector_free(T81Vector v);

// T81Matrix
T81Matrix t81_matrix_new(size_t rows, size_t cols);
T81Matrix t81_matrix_mul(T81Matrix a, T81Matrix b);
T81Float  t81_matrix_get(T81Matrix m, size_t row, size_t col);
void      t81_matrix_set(T81Matrix m, size_t row, size_t col, T81Float val);
void      t81_matrix_free(T81Matrix m);

#endif
@#
