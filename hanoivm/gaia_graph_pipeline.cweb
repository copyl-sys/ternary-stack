@* gaia_graph_pipeline.cweb
This document refactors the minimal GPU graph pipeline for integration with Hanoivm.
It defines an internal graph structure and a wrapper function to process a graph using GPU acceleration.

Recommendations:
1. **Interface Integration:**  
   Use the provided wrapper to convert internal Hanoivm graph structures into an edge list for GPU processing.
2. **Error Handling & Logging:**  
   The CUDA_CALL macro provides basic error checking, which can be expanded with logging as needed.
3. **Modular Design:**  
   The integration function isolates GPU execution details from the higher-level Hanoivm logic.
4. **Future Expansion:**  
   Expand the internal graph structure and conversion logic if your Hanoivm graph representation evolves.

@c
#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

@* Define error checking macro.
This macro wraps CUDA calls for error diagnostics.
@c
@<Error Checking Macros@>=
#define CUDA_CALL(call)                                     \
    do {                                                    \
        cudaError_t err = (call);                           \
        if (err != cudaSuccess) {                           \
            fprintf(stderr, "CUDA error at %s:%d: %s\n",    \
                    __FILE__, __LINE__, cudaGetErrorString(err)); \
            exit(EXIT_FAILURE);                             \
        }                                                   \
    } while (0)
@*

@* Kernel Function.
This kernel computes the degree for each vertex in the provided edge list.
Each edge is represented as a pair (u, v), and degrees are updated using atomic operations.
@c
__global__ void computeDegrees(int *edges, int numEdges, int *degrees) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < numEdges) {
        int u = edges[2 * idx];
        int v = edges[2 * idx + 1];
        // Increment degree for vertex u.
        atomicAdd(&degrees[u], 1);
        // For non-self-loop edges, increment degree for vertex v.
        if (u != v) {
            atomicAdd(&degrees[v], 1);
        }
    }
}

@* Internal Hanoivm Graph Structure.
This structure represents the graph as used within Hanoivm.
@c
typedef struct {
    int numVertices;
    int numEdges;
    int *edges; // Array of edges, where each edge is represented by two integers.
} hvm_graph;

@* run_gaia_graph_pipeline.
This function wraps the GPU pipeline for integration.
It accepts an hvm_graph pointer and an output array for vertex degrees.
@c
void run_gaia_graph_pipeline(const hvm_graph *graph, int *vertex_degrees) {
    int *d_edges, *d_degrees;
    size_t edgesSize = graph->numEdges * 2 * sizeof(int);
    size_t degreesSize = graph->numVertices * sizeof(int);

    // Allocate device memory.
    CUDA_CALL(cudaMalloc((void**)&d_edges, edgesSize));
    CUDA_CALL(cudaMalloc((void**)&d_degrees, degreesSize));

    // Copy the edge list from the internal graph to device memory.
    CUDA_CALL(cudaMemcpy(d_edges, graph->edges, edgesSize, cudaMemcpyHostToDevice));
    // Initialize device degrees array to zero.
    CUDA_CALL(cudaMemset(d_degrees, 0, degreesSize));

    // Launch the kernel.
    int threadsPerBlock = 256;
    int blocks = (graph->numEdges + threadsPerBlock - 1) / threadsPerBlock;
    computeDegrees<<<blocks, threadsPerBlock>>>(d_edges, graph->numEdges, d_degrees);
    CUDA_CALL(cudaGetLastError());
    CUDA_CALL(cudaDeviceSynchronize());

    // Copy the computed degrees back to the output array.
    CUDA_CALL(cudaMemcpy(vertex_degrees, d_degrees, degreesSize, cudaMemcpyDeviceToHost));

    // Free device memory.
    CUDA_CALL(cudaFree(d_edges));
    CUDA_CALL(cudaFree(d_degrees));
}

@* Main Function.
Simulates integration by constructing a sample hvm_graph and running the GPU graph pipeline.
@c
int main(void) {
    // Define a sample graph: 5 vertices, 6 edges.
    int sample_edges[] = {
        0, 1,  // Edge from vertex 0 to vertex 1.
        0, 2,  // Edge from vertex 0 to vertex 2.
        1, 2,  // Edge from vertex 1 to vertex 2.
        1, 3,  // Edge from vertex 1 to vertex 3.
        2, 3,  // Edge from vertex 2 to vertex 3.
        3, 4   // Edge from vertex 3 to vertex 4.
    };

    hvm_graph sample_graph;
    sample_graph.numVertices = 5;
    sample_graph.numEdges = 6;
    sample_graph.edges = sample_edges;

    // Allocate memory for vertex degrees.
    int vertex_degrees[5] = {0};

    // Run the GPU graph pipeline on the sample graph.
    run_gaia_graph_pipeline(&sample_graph, vertex_degrees);

    // Print the resulting vertex degrees.
    printf("Vertex degrees:\n");
    for (int i = 0; i < sample_graph.numVertices; i++) {
        printf("Vertex %d: %d\n", i, vertex_degrees[i]);
    }

    return 0;
}
